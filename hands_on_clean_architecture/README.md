# 만들면서 배우는 클린 아키텍처

## 클린 아키텍처란 (핵사고날 아키텍처) ?

계층형 아키텍처의 문제점을 개선한 것으로 도메인 계층이 어떠한 의존성을 가지지 않도록 한 것. (DDD 설계를 적극적으로 이용하는게 가능)

### 계층형 아키텍처의 문제점

먼저 계층형 아키텍처는 웹 (컨트롤러) → 도메인 (서비스) → 영속성 (데이터베이스) 로 구성됨.

이 구조의 문제점은 도메인 계층이 영속성 계층에 의존적이게 됨.

- 이 말은 영속성 계층의 변경 사항이 도메인 계층에 전파될 수도 있다는 것.
- ex) JPA 같은 ORM 을 쓰는 경우에 테이블 구조 변경 → 도메인 모델 변경을 일으키겠지.
- 이 뿐만 아니라 도메인 계층에 1차 캐시, 2차 캐시 지연 로딩, 즉시 로딩 이런 에노테이션을 붙이지 말자 라는 취지도 있음.

### 다시 돌아와서 클린 아키텍처를 보자. [https://binux.tistory.com/99](https://binux.tistory.com/99)

- 도메인 계층은 어떠한 의존성을 가지지 않는다.
- 어플리케이션이 제공해주는 핵심 기능 (use-case) 을 알 수 있다.
- 비즈니스 로직을 도메인 객체에게 위임.
- 외부 시스템 (= 데이터베이스) 는 도메인 객체와 연결되지 않음.
- 어플리케이션의 핵심 플로우를 알 수 있음.

### 이해를 위해 실제 패키지 구조를 통해서 보자.

> 어플리케이션 아키텍처는 패키지 구조를 따라야 한다. 그렇지 않으면 아키텍처와 코드 사이에는 갭 (Gap) 이 생길 것.
>

예시는 송금 서비스를 제공해주는 어플리케이션

```
buckpal
ㄴ account
    ㄴ adapter
        ㄴ in
            ㄴ web
                ㄴ AccountController
        ㄴ out
            ㄴ persistence
                ㄴ AccountPersistenceAdapter  
                ㄴ SpringDataAccountRepository
    ㄴ domain
        ㄴ Account
        ㄴ Activity
    ㄴ application
        ㄴ SendMoneyService (= interface) 
        ㄴ port
            ㄴ in
                ㄴ SendMoneyUseCase (= SendMoneySeviceImpl)
            ㄴ out
                ㄴ LoadAccountPort (= interface) 
                ㄴ UpdateAccountStatePort (= interface) 
```

- 웹 요청을 처음 받아주는 `인커밍 어댑터` 인 ``AccountController``
- 어플리케이션이 제공해주는 핵심 서비스를 말하는 `유스 케이스` 인 ``SendMoneyService``
    - 이름을 보고 어떠한 코드인지 알 수 있도록 하는 걸 [Screaming Architecture](https://www.youtube.com/watch?v=QkC2qIAbMtQ&t=6s) 라고 한다.
- 유스 케이스가 외부 프로세스와의 통신 (e.g 메시지 큐나 데이터베이스) 을 할 때 필요한 계약을 말해주는 `포트` 인 ``LoadAccountPort``  와 ``UpdateAccountStatePort``
- 포트와의 통신을 담당하는 `아웃커밍 어댑터` 인 ``AccountPersistenceAdapter``

## 어떻게 적용하면 되는가?

각 계층이 담당해야 할 역할 위주로 정리했다.

도메인 계층의 역할은 뻔해서 제외. 이건 DDD 에서 할 일.

- 그 중에 Aggregate Pattern 이라는게 있는데 이건 관련 있는 도메인 집합끼리는 협력을 적극적으로 하지만 서로 다른 집합 끼리는 필요한 결합만 하도록 하는 것.

### 웹 어댑터 계층의 역할

- HTTP 요청을 자바 객체로 매핑
- 요청 권한 검사하기
- 입력 유효성 검증하기
- 입력 객체를 유스 케이스 입력 모델로 변환하기
- 유스 케이스 호출하기
- 유스 케이스 출력을 HTTP 응답으로 보내기

### 유스 케이스의 역할

- 입력 받기
- 입력 유효성 검증은 하지 않는다. 이건 입력 모델이 하도록 함.
- 비즈니스 규칙 검증하기 (도메인 객체에 접근이 필요한 경우에 해당한다.)
- 도메인 모델 상태 조작하기
- 출력 반환하기

> Note. 조회만 하는 서비스의 경우에는 유스 케이스를 어떻게 처리하는게 좋을까?

읽기만 하는 경우에는 도메인 모델에 접근 할 필요가 없다. 바로 필요한 데이터만 조회하면 되니까.

이때는 유스 케이스라는 이름보다는 쿼리 서비스라고 네이밍을 지어서 구별하자. 이렇게 구별하는 걸 CQRS (Command-Query-Responsibility-Segregation) 이라고 한다.
>

> Note. 비즈니스 규칙을 검증할 때 canExecute() / Execute() 패턴을 써서 구별하는게 어떤가? 캡슐화를 잘 쓸 수 있을 듯.
>

### 영속성 어댑터 구현하기

- 입력을 받으면 데이터베이스에게 보내서 저장하기
- 데이터베이스 출력을 어플리케이션 포맷으로 변환하기.
- 주의) 트랜잭션의 경우에는 유스 케이스에서 관리하는게 더 낫다. 영속성 어댑터는 어디까지가 작업의 단위인지 알 지 못하니.

> Tip. 목 (Mock) 은 이런 `아웃커밍 어댑터` 에 적용하는 것이다.

목을 도메인 계층이나 유스 케이스에 쓰게 되는 순간에 `리팩터링 내성` 이라는 가치를 잃어버린다.

그리고 데이터베이스 계층은 목을 쓰지 않는 걸 추천한다. 이것도 변경될 여지가 많기 떄문에 `리팩터링 내성` 의 가치가 없어짐.

데이터베이스 만을 위한 테스트 보다는 통합 테스트가 훨씬 나음. 데이터베이스 테스트는 너무나 간단하기 때문에 시간 낭비.
>
